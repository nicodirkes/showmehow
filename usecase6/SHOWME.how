#!/usr/bin/env nextflow
import groovy.yaml.YamlBuilder


workflow {
    def species = params.species
    def model = params.model.name
    def use_model_jl = params.model.use_julia


    PULL_DATA_COSCINE (
        token_file = file("$moduleDir/pull_data/.token.txt"),
        project_name = "showmehow_usecase5",
        resource_name = "Field Data"
    )

    PREPROCESS_DATA(
        script = file("$moduleDir/preprocessing/preprocessing.py"),
        prefix = "data_ding_",
        species = species,
        indir = PULL_DATA_COSCINE.out
    )

    UQ_STATUS (
        PREPROCESS_DATA.out.done
    ) 
    
    if (use_model_jl) {
            SERVE_MODEL_JL(
            script = file("$moduleDir/model_julia/IH_model_server.jl"),
            src = file("$moduleDir/model_julia/src"),
            name = model,
            data = PREPROCESS_DATA.out.data, 
            UQ_STATUS.out.comm
        )
    }
    else {
        SERVE_MODEL(
            script = file("$moduleDir/model/IH_model_server.py"),
            src = file("$moduleDir/model/src"),
            name = model,
            data = PREPROCESS_DATA.out.data, 
            UQ_STATUS.out.comm
        )
    }

    CALIBRATION( 
        script = file("$moduleDir/mcmc/calibrate_emcee.py"),
        config = params,
        data = PREPROCESS_DATA.out.data,
        UQ_STATUS.out.comm
    )

    // DIAGNOSTICS(
    //   script = file("$moduleDir/diagnostics/run_diagnostics.py"),
    //   mcmc_results = CALIBRATION.out.mcmc_chain,
    //   outdir = "diagnostics_assesment",
    //   species = species,
    //   config = params,
    // )

    BUNDLE_OUTPUTS(
        experiment_params = params,
        mcmc_chain = CALIBRATION.out.mcmc_chain,
        mcmc_corner_plot = CALIBRATION.out.mcmc_corner_plot,
        mcmc_trace = CALIBRATION.out.mcmc_trace,
    )

}

process PULL_DATA_COSCINE {
    conda "$moduleDir/pull_data/environment.yml"
    publishDir "$moduleDir/outputs", mode: 'copy'
    
    input:
      path token_file
      val project_name
      val resource_name

    output:
      path "pulled_data"

    script:
        """
        #!/usr/bin/env python3
        import coscine

        # Read access token and setup client
        with open("$token_file", "rt") as fp:
	        token = fp.read()
        client = coscine.ApiClient(token)

        # Download the data
        resource = client.project("$project_name").resource("$resource_name")
        # resource = client.project("showmehow_usecase5").resource("Field Data")
        for file in resource.files():
            file.download(path="./pulled_data/")

        """

}

process PREPROCESS_DATA{
    conda "$moduleDir/preprocessing/environment.yml"

    input:
        file script
        val prefix
        val species
        path input

    output:
        path "${prefix}${species}_processed.csv", emit: data
        val true, emit: done

    script:
    """
    python3 preprocessing.py $species --prefix $prefix --indir $input  
    """
}

process UQ_STATUS {
    input:
    val ready

    script:
    """
    mkfifo status_info
    """

    output:
    path "status_info", emit: comm
}

process SERVE_MODEL {
    conda "$moduleDir/model/environment.yml"
    cache 'lenient'

    input:
    path script
    path src
    val name
    path data
    path status_comm

    script:
    """
    #!/bin/bash

    CHOSEN_PORT=""
    MAX_ATTEMPTS=20

    random_start_port() {
        echo \$(( (RANDOM % 16384) + 49152 ))
    }

    ATTEMPT_PORT=\$(random_start_port)

    try_port() {
        local candidate_port=\$1
        python ${script} --name ${name} --data ${data} --port \$candidate_port &
        SERVER_PID=\$!
        echo "Model Server PID: \$SERVER_PID (trying port \$candidate_port)"

        # poll for 30 seconds if model is up
        for _ in \$(seq 1 30); do
            if bash -c "echo > /dev/tcp/localhost/\$candidate_port" 2>/dev/null; then
                CHOSEN_PORT=\$candidate_port
                return 0
            fi
            if ! kill -0 \$SERVER_PID 2>/dev/null; then
                break
            fi
            sleep 1
        done

        kill \$SERVER_PID 2>/dev/null || true
        wait \$SERVER_PID 2>/dev/null || true
        return 1
    }

    ATTEMPT=1
    while [ \$ATTEMPT -le \$MAX_ATTEMPTS ]; do
        if try_port \$ATTEMPT_PORT; then
            break
        fi
        ATTEMPT=\$((ATTEMPT + 1))
        ATTEMPT_PORT=\$((ATTEMPT_PORT + 1 + (RANDOM % 100)))
    done

    if [ -z "\$CHOSEN_PORT" ]; then
        echo "Failed to start model server after \${MAX_ATTEMPTS} attempts" >&2
        exit 1
    fi

    echo "\$CHOSEN_PORT" > ${status_comm}
    echo "Model server is up and running on port \${CHOSEN_PORT}"


    # Monitor the status 
    cat ${status_comm}  &
    STATUS_PID=\$!
    wait \$STATUS_PID

    # Stop the model server when the signal is received
    kill \$SERVER_PID

    rm ${status_comm}
    
    """
}

process SERVE_MODEL_JL {
    container "bpc_hemolysis/model_julia" 
    // container "file://$moduleDir/model_julia/container.sif"
    cache 'lenient'

    input:
    path script
    path src
    val name
    path data
    path status_comm

    script:
    """
    #!/bin/bash

    CHOSEN_PORT=""
    MAX_ATTEMPTS=20

    random_start_port() {
        echo \$(( (RANDOM % 16384) + 49152 ))
    }

    ATTEMPT_PORT=\$(random_start_port)

    try_port() {
        local candidate_port=\$1
        julia ${script} --name ${name} --data ${data} --port \$candidate_port &
        SERVER_PID=\$!
        echo "Model Server PID: \$SERVER_PID (trying port \$candidate_port)"
        
        # poll for 30 seconds if model is up
        for _ in \$(seq 1 30); do
            if bash -c "echo > /dev/tcp/localhost/\$candidate_port" 2>/dev/null; then
                CHOSEN_PORT=\$candidate_port
                return 0
            fi
            if ! kill -0 \$SERVER_PID 2>/dev/null; then
                break
            fi
            sleep 1
        done

        kill \$SERVER_PID 2>/dev/null || true
        wait \$SERVER_PID 2>/dev/null || true
        return 1
    }

    ATTEMPT=1
    while [ \$ATTEMPT -le \$MAX_ATTEMPTS ]; do
        if try_port \$ATTEMPT_PORT; then
            break
        fi
        ATTEMPT=\$((ATTEMPT + 1))
        ATTEMPT_PORT=\$((ATTEMPT_PORT + 1 + (RANDOM % 100)))
    done

    if [ -z "\$CHOSEN_PORT" ]; then
        echo "Failed to start model server after \${MAX_ATTEMPTS} attempts" >&2
        exit 1
    fi

    echo "\$CHOSEN_PORT" > ${status_comm}
    echo "Model server is up and running on port \${CHOSEN_PORT}"

    # In order to use a single status_comm pipe
    sleep 5

    # Monitor the status 
    cat ${status_comm}  &
    STATUS_PID=\$!
    wait \$STATUS_PID

    # Stop the model server when the signal is received
    kill \$SERVER_PID

    rm ${status_comm}
    
    """
}

process CALIBRATION {
    conda "$moduleDir/mcmc/environment.yml"
    cache 'lenient'

    
    input:
    path script
    val config
    path data
    path status_comm


    script:
    def parameters = new YamlBuilder()
    parameters(config)
    """
    echo "${parameters.toString()}" > _params.yml

    MODEL_PORT=\$(cat ${status_comm})
    echo "Model server is up and running on port \${MODEL_PORT}"
    
    python ${script}  --config _params.yml --data ${data} --port \${MODEL_PORT}
    
    echo "mcmc_done" > ${status_comm} # signal to stop the model server
    """

    output:
    path "calibration_output*.npz", emit: mcmc_chain
    path "corner_plot*.png", emit: mcmc_corner_plot
    path "trace_*.npy", emit: mcmc_trace

}

process DIAGNOSTICS {
    conda "$moduleDir/diagnostics/environment.yml"
    publishDir "$moduleDir/outputs", mode: 'copy'

    input:
    path script
    path mcmc_results
    val outdir
    val species
    val config


    script:
    def parameters = new YamlBuilder()
    parameters(config)
    """
    #!/bin/bash
    echo "${parameters.toString()}" > _params.yml
    python3 ${script} --mcmc_results ${mcmc_results} --outdir "${outdir}_${mcmc_results.simpleName}" --species ${species} --config _params.yml
    """

    output:
    path "${outdir}_${mcmc_results.simpleName}"


}

process BUNDLE_OUTPUTS {
    publishDir "$moduleDir/outputs", mode: 'copy'

    input:
    val experiment_params
    path mcmc_chain
    path mcmc_corner_plot
    path mcmc_trace

    script:
    def parameters = new YamlBuilder()
    parameters(experiment_params)
    """
    #!/bin/bash
    echo "${parameters.toString()}" > _params.yml

    mkdir "${params.species}_${params.model.name}_${workflow.sessionId}"
    
    cp _params.yml "${params.species}_${params.model.name}_${workflow.sessionId}"
    cp ${mcmc_chain} "${params.species}_${params.model.name}_${workflow.sessionId}/"
    cp ${mcmc_corner_plot} "${params.species}_${params.model.name}_${workflow.sessionId}/"
    cp ${mcmc_trace} "${params.species}_${params.model.name}_${workflow.sessionId}/"
    """

    output:
    path "${params.species}_${params.model.name}_${workflow.sessionId}"
}
